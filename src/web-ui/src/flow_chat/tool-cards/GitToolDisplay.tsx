/**
 * Display component for the Git tool.
 */

import React, { useState, useCallback } from 'react';
import { useTranslation } from 'react-i18next';
import { ChevronDown, ChevronUp, GitBranch, CheckCircle, Check, X, AlertTriangle } from 'lucide-react';
import { CubeLoading, IconButton } from '../../component-library';
import type { ToolCardProps } from '../types/flow-chat';
import { BaseToolCard, ToolCardHeader } from './BaseToolCard';
import { Tooltip } from '@/component-library';
import { createLogger } from '@/shared/utils/logger';
import './GitToolDisplay.scss';

const log = createLogger('GitToolDisplay');

interface GitToolInput {
  operation?: string;
  args?: string;
  working_directory?: string;
  timeout?: number;
}

interface GitToolResultData {
  success?: boolean;
  exit_code?: number;
  stdout?: string;
  stderr?: string;
  execution_time_ms?: number;
  working_directory?: string;
  command?: string;
  operation?: string;
  timestamp?: string;
}

// Git operation colors; labels are translated at runtime.
const GIT_OPERATION_COLORS: Record<string, string> = {
  status: '#3b82f6',
  diff: '#8b5cf6',
  log: '#06b6d4',
  add: '#22c55e',
  commit: '#f59e0b',
  branch: '#ec4899',
  checkout: '#a855f7',
  switch: '#a855f7',
  pull: '#14b8a6',
  push: '#f97316',
  fetch: '#6366f1',
  merge: '#ef4444',
  rebase: '#dc2626',
  stash: '#84cc16',
  reset: '#f43f5e',
  restore: '#10b981',
  show: '#64748b',
  tag: '#eab308',
  remote: '#0ea5e9',
  clone: '#7c3aed',
  init: '#059669',
  blame: '#94a3b8',
  'cherry-pick': '#fb923c',
};

export const GitToolDisplay: React.FC<ToolCardProps> = ({
  toolItem,
  onConfirm,
  onReject
}) => {
  const { t } = useTranslation('flow-chat');
  const { status, toolCall, toolResult, requiresConfirmation, userConfirmed } = toolItem;
  const [isExpanded, setIsExpanded] = useState(false);

  const getInputData = (): GitToolInput | null => {
    if (!toolCall?.input) return null;
    
    const isEarlyDetection = toolCall.input._early_detection === true;
    const isPartialParams = toolCall.input._partial_params === true;
    
    if (isEarlyDetection || isPartialParams) {
      return null;
    }
    
    return toolCall.input as GitToolInput;
  };

  const getResultData = (): GitToolResultData | null => {
    if (!toolResult?.result) return null;
    
    try {
      if (typeof toolResult.result === 'string') {
        return JSON.parse(toolResult.result);
      }
      return toolResult.result as GitToolResultData;
    } catch (e) {
      log.error('Failed to parse result', e);
      return null;
    }
  };

  const inputData = getInputData();
  const resultData = getResultData();

  const getOperationInfo = () => {
    const operation = inputData?.operation || resultData?.operation || 'unknown';
    const color = GIT_OPERATION_COLORS[operation] || '#6b7280';
    const labelKey = `toolCards.git.${operation}`;
    const label = t(labelKey, { defaultValue: operation });
    return { label, color };
  };

  const operationInfo = getOperationInfo();

  const getCommandDisplay = () => {
    if (resultData?.command) return resultData.command;
    if (!inputData?.operation) return 'git';
    
    let cmd = `git ${inputData.operation}`;
    if (inputData.args) {
      cmd += ` ${inputData.args}`;
    }
    return cmd;
  };

  const getOutputSummary = () => {
    if (!resultData) return null;
    
    const stdout = resultData.stdout?.trim() || '';
    const stderr = resultData.stderr?.trim() || '';
    
    if (!stdout && !stderr) return t('toolCards.git.noOutput');
    
    const output = stdout || stderr;
    const firstLine = output.split('\n')[0];
    if (firstLine.length > 60) {
      return firstLine.substring(0, 60) + '...';
    }
    return firstLine;
  };

  const outputSummary = getOutputSummary();
  const hasOutput = resultData && (resultData.stdout || resultData.stderr);
  
  const isLoading = status === 'preparing' || status === 'streaming' || status === 'running';

  const isFailed = status === 'error' || (resultData && resultData.exit_code !== 0);

  const hasWarning = resultData && resultData.success && resultData.stderr;

  const getErrorMessage = () => {
    if (toolResult && 'error' in toolResult) {
      return toolResult.error;
    }
    if (resultData?.stderr) {
      return resultData.stderr;
    }
    return t('toolCards.git.executionFailed');
  };

  const handleCardClick = useCallback((e: React.MouseEvent) => {
    const target = e.target as HTMLElement;
    if (target.closest('.preview-toggle-btn') || target.closest('.git-action-buttons')) {
      return;
    }
    
    if (hasOutput || isFailed) {
      setIsExpanded(!isExpanded);
    }
  }, [isExpanded, hasOutput, isFailed]);

  const renderToolIcon = () => {
    return <GitBranch size={16} />;
  };

  const renderStatusIcon = () => {
    if (isLoading) {
      return <CubeLoading size="small" />;
    }
    if (status === 'completed' && !isFailed) {
      if (hasWarning) {
        return <AlertTriangle className="icon-warning" size={14} />;
      }
      return <CheckCircle className="icon-completed" size={14} />;
    }
    return null;
  };

  const renderHeader = () => (
    <ToolCardHeader
      icon={renderToolIcon()}
      iconClassName="git-icon"
      action={isFailed ? t('toolCards.git.commandFailed') : `${t('toolCards.git.title')}:`}
      content={
        <span className="git-tool-info">
          <span className="operation-tag">
            {operationInfo.label}
          </span>
          <span className="command-text">{getCommandDisplay()}</span>
        </span>
      }
      extra={
        <>
          {!isFailed && outputSummary && status === 'completed' && (
            <span className="output-summary">
              {outputSummary}
            </span>
          )}
          
          {requiresConfirmation && !userConfirmed && status !== 'completed' && (
            <div className="git-action-buttons">
              <IconButton
                className="git-icon-button git-confirm-btn"
                variant="success"
                size="xs"
                onClick={(e) => {
                  e.stopPropagation();
                  onConfirm?.(toolCall?.input);
                }}
                disabled={status === 'streaming'}
                tooltip={t('toolCards.git.confirmExecute')}
              >
                <Check size={14} />
              </IconButton>
              <IconButton
                className="git-icon-button git-reject-btn"
                variant="danger"
                size="xs"
                onClick={(e) => {
                  e.stopPropagation();
                  onReject?.();
                }}
                disabled={status === 'streaming'}
                tooltip={t('toolCards.git.cancel')}
              >
                <X size={14} />
              </IconButton>
            </div>
          )}
          
          {(hasOutput || isFailed) && (
            <IconButton
              className="preview-toggle-btn"
              variant="ghost"
              size="xs"
              onClick={(e) => {
                e.stopPropagation();
                setIsExpanded(!isExpanded);
              }}
              tooltip={isExpanded ? t('toolCards.git.collapseOutput') : t('toolCards.git.expandOutput')}
            >
              {isExpanded ? <ChevronUp size={12} /> : <ChevronDown size={12} />}
            </IconButton>
          )}
          
          {isFailed && (
            <div className="error-indicator">
              <span className="error-text">{t('toolCards.git.failed')}</span>
            </div>
          )}
        </>
      }
      statusIcon={renderStatusIcon()}
    />
  );

  const renderExpandedContent = () => {
    if (!resultData) return null;

    const { stdout, stderr, exit_code, execution_time_ms, working_directory } = resultData;

    return (
      <div className="git-expanded-content">
        <div className="git-meta-info">
          {exit_code !== undefined && (
            <span className={`meta-item ${exit_code === 0 ? 'success' : 'error'}`}>
              {t('toolCards.git.exitCode', { code: exit_code })}
            </span>
          )}
          {execution_time_ms !== undefined && (
            <span className="meta-item">
              {t('toolCards.git.duration', { time: execution_time_ms >= 1000 
                ? `${(execution_time_ms / 1000).toFixed(2)}s` 
                : `${execution_time_ms}ms` })}
            </span>
          )}
          {working_directory && (
            <span className="meta-item working-dir" title={working_directory}>
              {t('toolCards.git.directory', { dir: working_directory.split(/[/\\]/).pop() })}
            </span>
          )}
        </div>

        {stdout && (
          <div className="output-section">
            <div className="output-label">{t('toolCards.git.output')}</div>
            <pre className="output-content stdout">{stdout}</pre>
          </div>
        )}

        {stderr && (
          <div className="output-section">
            <div className="output-label error-label">
              {resultData.success ? t('toolCards.git.warning') : t('toolCards.git.error')}
            </div>
            <pre className={`output-content ${resultData.success ? 'warning' : 'stderr'}`}>
              {stderr}
            </pre>
          </div>
        )}
      </div>
    );
  };

  const renderErrorContent = () => (
    <div className="error-content">
      <div className="error-message">{getErrorMessage()}</div>
      {inputData?.operation && (
        <div className="error-meta">
          <span className="error-operation">{t('toolCards.git.operation', { op: inputData.operation })}</span>
          {inputData.args && (
            <>
              <span className="error-separator">|</span>
              <span className="error-args">{t('toolCards.git.args', { args: inputData.args })}</span>
            </>
          )}
        </div>
      )}
    </div>
  );

  return (
    <BaseToolCard
      status={status}
      isExpanded={isExpanded}
      onClick={handleCardClick}
      className="git-tool-display"
      header={renderHeader()}
      expandedContent={renderExpandedContent()}
      errorContent={renderErrorContent()}
      isFailed={(isFailed && status === 'error') || undefined}
      requiresConfirmation={requiresConfirmation && !userConfirmed}
    />
  );
};

